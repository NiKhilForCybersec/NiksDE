<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PowerShell for Security - Detection Engineering Mastery</title>
    <link rel="stylesheet" href="../../css/main.css">
</head>
<body>
    <div class="layout">
        <nav class="sidebar">
            <div class="sidebar-header">
                <a href="../../index.html" class="logo">
                    <svg class="logo-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 2L2 7l10 5 10-5-10-5z"></path><path d="M2 17l10 5 10-5"></path><path d="M2 12l10 5 10-5"></path></svg>
                    <span>Detection Engineering</span>
                </a>
            </div>
            <div class="nav-sections">
                <div class="nav-section expanded" data-section="automation">
                    <div class="nav-section-header">
                        <div class="nav-section-title">
                            <svg class="nav-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="16 18 22 12 16 6"></polyline><polyline points="8 6 2 12 8 18"></polyline></svg>
                            <span>Automation & Scripting</span>
                        </div>
                    </div>
                    <div class="nav-items">
                        <a href="fundamentals.html" class="nav-item">Automation Fundamentals</a>
                        <a href="python-security.html" class="nav-item">Python for Security</a>
                        <a href="powershell-security.html" class="nav-item active">PowerShell for Security</a>
                        <a href="bash-security.html" class="nav-item">Bash for Security</a>
                        <a href="soar.html" class="nav-item">SOAR Platforms</a>
                        <a href="api-integration.html" class="nav-item">API Integration</a>
                    </div>
                </div>
            </div>
        </nav>

        <main class="main-content">
            <div class="content">
                <nav class="breadcrumb">
                    <a href="../../index.html">Home</a>
                    <span class="separator">/</span>
                    <a href="fundamentals.html">Automation</a>
                    <span class="separator">/</span>
                    <span class="current">PowerShell for Security</span>
                </nav>

                <header class="page-header">
                    <h1>PowerShell for Security</h1>
                    <p class="subtitle">Essential PowerShell skills for Windows security automation, Active Directory management, and Microsoft 365 security operations.</p>
                </header>

                <section class="content-section">
                    <h2>Security-Relevant Modules</h2>
                    
                    <table class="styled-table">
                        <thead>
                            <tr>
                                <th>Module</th>
                                <th>Purpose</th>
                                <th>Install</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><code>ActiveDirectory</code></td>
                                <td>AD user, group, computer management</td>
                                <td>RSAT or Windows Server</td>
                            </tr>
                            <tr>
                                <td><code>Az</code></td>
                                <td>Azure resource management</td>
                                <td><code>Install-Module Az</code></td>
                            </tr>
                            <tr>
                                <td><code>Microsoft.Graph</code></td>
                                <td>Entra ID, M365 via Graph API</td>
                                <td><code>Install-Module Microsoft.Graph</code></td>
                            </tr>
                            <tr>
                                <td><code>ExchangeOnlineManagement</code></td>
                                <td>Exchange Online administration</td>
                                <td><code>Install-Module ExchangeOnlineManagement</code></td>
                            </tr>
                            <tr>
                                <td><code>MicrosoftTeams</code></td>
                                <td>Teams administration</td>
                                <td><code>Install-Module MicrosoftTeams</code></td>
                            </tr>
                            <tr>
                                <td><code>ImportExcel</code></td>
                                <td>Excel report generation</td>
                                <td><code>Install-Module ImportExcel</code></td>
                            </tr>
                        </tbody>
                    </table>
                </section>

                <section class="content-section">
                    <h2>Active Directory Security</h2>

                    <h3>Find Privileged Accounts</h3>
                    <div class="code-block">
                        <div class="code-header">
                            <span>Get-PrivilegedAccounts.ps1</span>
                            <button class="copy-btn">Copy</button>
                        </div>
                        <pre><code># Get members of privileged AD groups
$PrivilegedGroups = @(
    "Domain Admins",
    "Enterprise Admins", 
    "Schema Admins",
    "Administrators",
    "Account Operators",
    "Backup Operators",
    "Server Operators"
)

$Results = foreach ($Group in $PrivilegedGroups) {
    try {
        $Members = Get-ADGroupMember -Identity $Group -Recursive | 
            Where-Object { $_.objectClass -eq 'user' }
        
        foreach ($Member in $Members) {
            $User = Get-ADUser -Identity $Member -Properties LastLogonDate, PasswordLastSet, Enabled
            [PSCustomObject]@{
                Group = $Group
                Username = $User.SamAccountName
                DisplayName = $User.Name
                Enabled = $User.Enabled
                LastLogon = $User.LastLogonDate
                PasswordLastSet = $User.PasswordLastSet
                PasswordAge = if ($User.PasswordLastSet) { (Get-Date) - $User.PasswordLastSet } else { "Never" }
            }
        }
    } catch {
        Write-Warning "Failed to query group: $Group - $_"
    }
}

# Export report
$Results | Export-Csv -Path "PrivilegedAccounts_$(Get-Date -Format 'yyyyMMdd').csv" -NoTypeInformation

# Summary
$Results | Group-Object Group | Select-Object Name, Count | Format-Table</code></pre>
                    </div>

                    <h3>Detect Stale Accounts</h3>
                    <div class="code-block">
                        <div class="code-header">
                            <span>Find-StaleAccounts.ps1</span>
                            <button class="copy-btn">Copy</button>
                        </div>
                        <pre><code># Find accounts with no recent logon
param(
    [int]$DaysInactive = 90
)

$CutoffDate = (Get-Date).AddDays(-$DaysInactive)

# Stale user accounts
$StaleUsers = Get-ADUser -Filter {
    Enabled -eq $true -and 
    LastLogonDate -lt $CutoffDate
} -Properties LastLogonDate, PasswordLastSet, Description |
Select-Object SamAccountName, Name, LastLogonDate, PasswordLastSet, Description

Write-Host "Found $($StaleUsers.Count) users inactive for $DaysInactive+ days" -ForegroundColor Yellow

# Stale computer accounts
$StaleComputers = Get-ADComputer -Filter {
    Enabled -eq $true -and 
    LastLogonDate -lt $CutoffDate
} -Properties LastLogonDate, OperatingSystem |
Select-Object Name, LastLogonDate, OperatingSystem

Write-Host "Found $($StaleComputers.Count) computers inactive for $DaysInactive+ days" -ForegroundColor Yellow

# Export
$StaleUsers | Export-Csv "StaleUsers_$DaysInactive`days.csv" -NoTypeInformation
$StaleComputers | Export-Csv "StaleComputers_$DaysInactive`days.csv" -NoTypeInformation</code></pre>
                    </div>

                    <h3>Kerberoasting Detection</h3>
                    <div class="code-block">
                        <div class="code-header">
                            <span>Find-KerberoastTargets.ps1</span>
                            <button class="copy-btn">Copy</button>
                        </div>
                        <pre><code># Find accounts vulnerable to Kerberoasting
# Service accounts with SPNs that can be requested by any domain user

$KerberoastTargets = Get-ADUser -Filter {ServicePrincipalName -ne "$null"} -Properties `
    ServicePrincipalName, PasswordLastSet, LastLogonDate, MemberOf, Description |
Where-Object { $_.Enabled -eq $true } |
Select-Object @{N='Username';E={$_.SamAccountName}},
              @{N='SPNs';E={$_.ServicePrincipalName -join ', '}},
              @{N='PasswordAge';E={(New-TimeSpan -Start $_.PasswordLastSet).Days}},
              @{N='LastLogon';E={$_.LastLogonDate}},
              @{N='PrivilegedGroups';E={
                  $privGroups = $_.MemberOf | ForEach-Object {
                      (Get-ADGroup $_).Name
                  } | Where-Object { $_ -match 'Admin|Operator|Manager' }
                  $privGroups -join ', '
              }},
              Description

# High risk: old password + privileged
$HighRisk = $KerberoastTargets | Where-Object { 
    $_.PasswordAge -gt 365 -and $_.PrivilegedGroups 
}

Write-Host "`nKerberoastable Accounts: $($KerberoastTargets.Count)" -ForegroundColor Cyan
Write-Host "High Risk (old password + privileged): $($HighRisk.Count)" -ForegroundColor Red

$KerberoastTargets | Format-Table -AutoSize
$KerberoastTargets | Export-Csv "KerberoastTargets.csv" -NoTypeInformation</code></pre>
                    </div>
                </section>

                <section class="content-section">
                    <h2>Windows Security Events</h2>

                    <h3>Query Security Events</h3>
                    <div class="code-block">
                        <div class="code-header">
                            <span>Get-SecurityEvents.ps1</span>
                            <button class="copy-btn">Copy</button>
                        </div>
                        <pre><code># Query security events from Windows Event Log
param(
    [string]$ComputerName = $env:COMPUTERNAME,
    [int]$Hours = 24,
    [int[]]$EventIds = @(4624, 4625, 4648, 4672, 4720, 4728, 4732)
)

$StartTime = (Get-Date).AddHours(-$Hours)

$FilterHash = @{
    LogName = 'Security'
    StartTime = $StartTime
    ID = $EventIds
}

$Events = Get-WinEvent -ComputerName $ComputerName -FilterHashtable $FilterHash -ErrorAction SilentlyContinue

$ParsedEvents = foreach ($Event in $Events) {
    $XmlData = [xml]$Event.ToXml()
    $EventData = @{}
    
    foreach ($Data in $XmlData.Event.EventData.Data) {
        $EventData[$Data.Name] = $Data.'#text'
    }
    
    [PSCustomObject]@{
        TimeCreated = $Event.TimeCreated
        EventId = $Event.Id
        Computer = $Event.MachineName
        TargetUser = $EventData['TargetUserName']
        SourceIP = $EventData['IpAddress']
        LogonType = $EventData['LogonType']
        Status = $EventData['Status']
        SubjectUser = $EventData['SubjectUserName']
    }
}

# Summary by event type
$ParsedEvents | Group-Object EventId | 
    Select-Object @{N='EventId';E={$_.Name}}, Count | 
    Format-Table

# Failed logons by IP
$ParsedEvents | Where-Object EventId -eq 4625 | 
    Group-Object SourceIP | 
    Sort-Object Count -Descending | 
    Select-Object -First 10 Name, Count</code></pre>
                    </div>

                    <h3>Detect Brute Force</h3>
                    <div class="code-block">
                        <div class="code-header">
                            <span>Detect-BruteForce.ps1</span>
                            <button class="copy-btn">Copy</button>
                        </div>
                        <pre><code># Detect brute force attempts from Security log
param(
    [int]$Threshold = 10,
    [int]$TimeWindowMinutes = 15
)

$StartTime = (Get-Date).AddMinutes(-$TimeWindowMinutes)

# Get failed logon events (4625)
$FailedLogons = Get-WinEvent -FilterHashtable @{
    LogName = 'Security'
    ID = 4625
    StartTime = $StartTime
} -ErrorAction SilentlyContinue | ForEach-Object {
    $Xml = [xml]$_.ToXml()
    $EventData = @{}
    foreach ($Data in $Xml.Event.EventData.Data) {
        $EventData[$Data.Name] = $Data.'#text'
    }
    
    [PSCustomObject]@{
        Time = $_.TimeCreated
        SourceIP = $EventData['IpAddress']
        TargetUser = $EventData['TargetUserName']
        FailureReason = $EventData['FailureReason']
        Status = $EventData['Status']
    }
}

# Group by source IP
$AttackSources = $FailedLogons | 
    Where-Object { $_.SourceIP -and $_.SourceIP -ne '-' } |
    Group-Object SourceIP |
    Where-Object { $_.Count -ge $Threshold } |
    Select-Object @{N='SourceIP';E={$_.Name}},
                  @{N='FailedAttempts';E={$_.Count}},
                  @{N='TargetUsers';E={($_.Group.TargetUser | Select-Object -Unique) -join ', '}}

if ($AttackSources) {
    Write-Host "`n⚠️  POTENTIAL BRUTE FORCE DETECTED!" -ForegroundColor Red
    $AttackSources | Format-Table -AutoSize
    
    # Optional: Block IPs via Windows Firewall
    # foreach ($Attacker in $AttackSources) {
    #     New-NetFirewallRule -DisplayName "Block $($Attacker.SourceIP)" `
    #         -Direction Inbound -RemoteAddress $Attacker.SourceIP -Action Block
    # }
} else {
    Write-Host "No brute force patterns detected in last $TimeWindowMinutes minutes" -ForegroundColor Green
}</code></pre>
                    </div>
                </section>

                <section class="content-section">
                    <h2>Microsoft 365 Security</h2>

                    <h3>Audit MFA Status</h3>
                    <div class="code-block">
                        <div class="code-header">
                            <span>Get-MFAStatus.ps1</span>
                            <button class="copy-btn">Copy</button>
                        </div>
                        <pre><code># Get MFA status for all users via Microsoft Graph
# Requires: Microsoft.Graph module

Connect-MgGraph -Scopes "User.Read.All", "UserAuthenticationMethod.Read.All"

$Users = Get-MgUser -All -Property Id, DisplayName, UserPrincipalName, AccountEnabled

$MFAReport = foreach ($User in $Users) {
    $AuthMethods = Get-MgUserAuthenticationMethod -UserId $User.Id
    
    $MFAMethods = $AuthMethods | Where-Object {
        $_.AdditionalProperties.'@odata.type' -in @(
            '#microsoft.graph.microsoftAuthenticatorAuthenticationMethod',
            '#microsoft.graph.phoneAuthenticationMethod',
            '#microsoft.graph.fido2AuthenticationMethod',
            '#microsoft.graph.windowsHelloForBusinessAuthenticationMethod'
        )
    }
    
    [PSCustomObject]@{
        DisplayName = $User.DisplayName
        UPN = $User.UserPrincipalName
        Enabled = $User.AccountEnabled
        MFAEnabled = ($MFAMethods.Count -gt 0)
        MFAMethodCount = $MFAMethods.Count
        Methods = ($MFAMethods | ForEach-Object { 
            $_.AdditionalProperties.'@odata.type' -replace '#microsoft.graph.', '' -replace 'AuthenticationMethod', ''
        }) -join ', '
    }
}

# Users without MFA
$NoMFA = $MFAReport | Where-Object { $_.Enabled -and -not $_.MFAEnabled }
Write-Host "Users without MFA: $($NoMFA.Count)" -ForegroundColor Red

$MFAReport | Export-Csv "MFA_Status_Report.csv" -NoTypeInformation
$NoMFA | Format-Table DisplayName, UPN</code></pre>
                    </div>

                    <h3>Review Sign-in Logs</h3>
                    <div class="code-block">
                        <div class="code-header">
                            <span>Get-RiskySignIns.ps1</span>
                            <button class="copy-btn">Copy</button>
                        </div>
                        <pre><code># Get risky sign-ins from Entra ID
# Requires: Microsoft.Graph module with appropriate permissions

Connect-MgGraph -Scopes "AuditLog.Read.All"

# Get sign-ins from last 24 hours
$StartDate = (Get-Date).AddDays(-1).ToString("yyyy-MM-ddTHH:mm:ssZ")

# Failed sign-ins
$FailedSignIns = Get-MgAuditLogSignIn -Filter "createdDateTime ge $StartDate and status/errorCode ne 0" -Top 100

$FailedReport = $FailedSignIns | Select-Object `
    @{N='Time';E={$_.CreatedDateTime}},
    @{N='User';E={$_.UserPrincipalName}},
    @{N='App';E={$_.AppDisplayName}},
    @{N='IP';E={$_.IpAddress}},
    @{N='Location';E={"$($_.Location.City), $($_.Location.CountryOrRegion)"}},
    @{N='ErrorCode';E={$_.Status.ErrorCode}},
    @{N='FailureReason';E={$_.Status.FailureReason}},
    @{N='RiskLevel';E={$_.RiskLevelDuringSignIn}}

# Group by error and IP
Write-Host "`nFailed Sign-ins by Error Code:" -ForegroundColor Cyan
$FailedReport | Group-Object ErrorCode | Sort-Object Count -Descending | 
    Select-Object -First 10 Name, Count | Format-Table

Write-Host "`nTop Source IPs for Failures:" -ForegroundColor Cyan
$FailedReport | Group-Object IP | Sort-Object Count -Descending |
    Select-Object -First 10 Name, Count | Format-Table

# Risky sign-ins
$RiskySignIns = Get-MgAuditLogSignIn -Filter "riskLevelDuringSignIn ne 'none' and createdDateTime ge $StartDate" -Top 50

if ($RiskySignIns) {
    Write-Host "`n⚠️  Risky Sign-ins Detected:" -ForegroundColor Red
    $RiskySignIns | Select-Object CreatedDateTime, UserPrincipalName, RiskLevelDuringSignIn, IpAddress | 
        Format-Table
}

$FailedReport | Export-Csv "FailedSignIns.csv" -NoTypeInformation</code></pre>
                    </div>
                </section>

                <section class="content-section">
                    <h2>Incident Response</h2>

                    <h3>User Account Investigation</h3>
                    <div class="code-block">
                        <div class="code-header">
                            <span>Investigate-User.ps1</span>
                            <button class="copy-btn">Copy</button>
                        </div>
                        <pre><code>param(
    [Parameter(Mandatory)]
    [string]$Username
)

Write-Host "=== Investigating User: $Username ===" -ForegroundColor Cyan

# AD Information
$ADUser = Get-ADUser -Identity $Username -Properties *
Write-Host "`n[AD Account Info]" -ForegroundColor Yellow
$ADUser | Select-Object SamAccountName, DisplayName, EmailAddress, 
    Enabled, LockedOut, LastLogonDate, PasswordLastSet, 
    whenCreated, Description | Format-List

# Group memberships
Write-Host "`n[Group Memberships]" -ForegroundColor Yellow
$Groups = Get-ADPrincipalGroupMembership -Identity $Username | Select-Object Name
$Groups | Format-Table -AutoSize

# Recent logons (last 7 days)
Write-Host "`n[Recent Logon Events - Last 7 Days]" -ForegroundColor Yellow
$DCs = Get-ADDomainController -Filter *
foreach ($DC in $DCs) {
    $Events = Get-WinEvent -ComputerName $DC.HostName -FilterHashtable @{
        LogName = 'Security'
        ID = 4624
        StartTime = (Get-Date).AddDays(-7)
    } -ErrorAction SilentlyContinue | Where-Object {
        ([xml]$_.ToXml()).Event.EventData.Data | 
            Where-Object { $_.Name -eq 'TargetUserName' -and $_.'#text' -eq $Username }
    } | Select-Object -First 10 TimeCreated, 
        @{N='SourceIP';E={([xml]$_.ToXml()).Event.EventData.Data | Where-Object Name -eq 'IpAddress' | Select-Object -Expand '#text'}}
    
    if ($Events) {
        Write-Host "From DC: $($DC.HostName)" -ForegroundColor Gray
        $Events | Format-Table
    }
}

# Check for lockout events
Write-Host "`n[Account Lockout Events]" -ForegroundColor Yellow
$LockoutEvents = Get-WinEvent -FilterHashtable @{
    LogName = 'Security'
    ID = 4740
    StartTime = (Get-Date).AddDays(-7)
} -ErrorAction SilentlyContinue | Where-Object {
    $_.Message -match $Username
}
if ($LockoutEvents) {
    $LockoutEvents | Select-Object TimeCreated, Message | Format-Table
} else {
    Write-Host "No recent lockout events"
}</code></pre>
                    </div>
                </section>

                <section class="content-section">
                    <h2>Interview Preparation</h2>
                    
                    <div class="expandable">
                        <button class="expandable-header">
                            <span>Q: How do you securely handle credentials in PowerShell scripts?</span>
                            <span class="expand-icon">+</span>
                        </button>
                        <div class="expandable-content">
                            <div class="code-block">
                                <pre><code># NEVER do this:
$password = "PlainTextPassword"  # ❌

# Better approaches:

# 1. SecureString with encrypted file (machine-specific)
$credential = Get-Credential
$credential.Password | ConvertFrom-SecureString | Set-Content "cred.txt"
# To retrieve:
$securePass = Get-Content "cred.txt" | ConvertTo-SecureString
$cred = New-Object PSCredential("username", $securePass)

# 2. Windows Credential Manager
Install-Module CredentialManager
New-StoredCredential -Target "MyApp" -UserName "user" -Password "pass"
$cred = Get-StoredCredential -Target "MyApp"

# 3. Azure Key Vault (for cloud)
$secret = Get-AzKeyVaultSecret -VaultName "MyVault" -Name "MySecret"

# 4. Environment variables (CI/CD)
$apiKey = $env:API_KEY</code></pre>
                            </div>
                        </div>
                    </div>

                    <div class="expandable">
                        <button class="expandable-header">
                            <span>Q: Write PowerShell to find all users who haven't changed their password in 90 days.</span>
                            <span class="expand-icon">+</span>
                        </button>
                        <div class="expandable-content">
                            <div class="code-block">
                                <pre><code>$DaysThreshold = 90
$CutoffDate = (Get-Date).AddDays(-$DaysThreshold)

Get-ADUser -Filter {
    Enabled -eq $true -and
    PasswordNeverExpires -eq $false -and
    PasswordLastSet -lt $CutoffDate
} -Properties PasswordLastSet, LastLogonDate, Mail |
Select-Object SamAccountName, 
    @{N='PasswordAge';E={(New-TimeSpan $_.PasswordLastSet).Days}},
    PasswordLastSet,
    LastLogonDate,
    Mail |
Sort-Object PasswordAge -Descending |
Export-Csv "OldPasswords.csv" -NoTypeInformation</code></pre>
                            </div>
                        </div>
                    </div>
                </section>

                <nav class="page-nav">
                    <a href="python-security.html" class="nav-link prev">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="15 18 9 12 15 6"></polyline></svg>
                        Python for Security
                    </a>
                    <a href="bash-security.html" class="nav-link next">
                        Bash for Security
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="9 18 15 12 9 6"></polyline></svg>
                    </a>
                </nav>
            </div>
        </main>
    </div>
    <script src="../../js/sidebar.js"></script>
</body>
</html>
